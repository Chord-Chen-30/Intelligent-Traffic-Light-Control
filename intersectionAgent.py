from car import Car
from car import status
import copy
import random

class IntersectionAgent:
    def __init__(self, list_of_cars):

        self.__time = 0 # Simulate the real time
        self.TIME_INTERVAL = 20
        self.epsilon = 0.5 # How much probability we choose to take a random action
        self.__light_states = {'straight1':[], \
                               'straight2':[], \
                               'left1':[], \
                               'left2':[] }

        self.cur_light_state = 'straight1'

        self.buffer_car_list = copy.deepcopy(list_of_cars) # Cars that have not reached intersecion (yet) but generated by test case, store here for now
        self.waiting_car_list = [] # Maybe we need 8, or 4

        self.passed_car_list = [] # Maybe we need 1





    """============Basic functions============"""

    # Add one car to waiting list of this intersection
    def add_car_to_waiting_list(self, car):
        self.waiting_car_list.append(car)

    def get_legal_action(self):
        return ['straight1','straight2','left1','left2']

    # Update all cars' status after ?? seconds passed
    # Include their status and waiting time
    def update_car_status(self):
        pass
    
    # 
    def time_elapse(self):
        self.__time += self.TIME_INTERVAL
        """ YOUR CODE HERE"""
        # 1. Select cars from buffer list into waiting list based on the current time __TIME
        # 2. Select cars in waiting list but crossed intersection out of the list, mark them status.EXIT


    def all_cars_passed(self):
        if self.waiting_car_list == []:
            return True
        else:
            return False

    # Update intersection state every TIME_INTERVAL
    # ACTION should be 'straight1' or 'straight2' or ...
    # def get_next_state(self, action):
    #     for car in self.waiting_car_list:
    #         """YOUR CODE HERE"""
    #         # We should get the first N cars of some waiting list and mark them as status.EXIT
    #         # and kick them out from waiting list and add them into passed_car_list
    #         # ...Maybe we sort them earlier than here ?
    #         pass


    """============Functions refer to learnging (Approximate Q learning)============"""
    # Compute  action based on Q values
    def compute_action_from_qvalues(self, state):
        action = None
        lights_choices = self.get_legal_action()

        highest_qvalue = -float('inf')
        for a in lights_choices:
            qvalue = self.get_qvalue(state, a)
            if qvalue > highest_qvalue:
                action = a
                highest_qvalue = qvalue

        # ACTION should be one of ['straight1','straight2','left1','left2']
        if (highest_qvalue == 0): # For debug
            print("action: %s computed from q value but zero q value (meaningless)", action)
        return action


    # Get action by random or computing
    def get_action(self, state):
        action = None
        choosing_random = (random.random()>self.epsilon)
        if choosing_random:
            return random.choice(self.get_legal_action())
        else:
            return self.compute_action_from_qvalues(state)


    def get_qvalue(self):
        """ YOUR CODE HERE"""
        pass

    def update(self):
        """ YOUR CODE HERE"""
        pass




    """============Training and testing============"""
    def train(self):
        """ YOUR CODE HERE"""
        pass

    def test(self, test_cars):
        """ YOUR CODE HERE"""
        pass


    def stupid_ai(self):
        """ YOUR CODE HERE"""
        # Solve the cars in a regular way, i.e. a evenly scheme to control traffic light
        # And calculate the total waiting time (or sth else we use to evaluate our model)
        pass